编写操作系统日志
前言
我做了两个小型系统，一个是分布式数据处理的amoyensis，计划是scheduler + key-value storage, 一致性协议是Raft。
但是因为暂时无法找到分布式的测试环境，云上的主机也租不起，所以目前只实现了Raft，暂时搁置了下来。
另一个就是操作系统orcas，是一个单机的操作系统，计划将进程管理、内存管理、设备驱动和文件系统四部分做完。
如果后续有时间，可能会添加网络和进程间通信。

GDT
操作系统的课程中的段页式管理，所谓的分段，就是将内存分为多个段，以内核为例，有数据段和代码段。
操作系统再在段的基础上进行分页。全局描述符表Global descriptor table是管理系统分段的数据结构。
GDT是操作系统各种功能的基础。实现中断的IDT依赖于GDT，内存管理分页也依赖于GDT。
所以想要实现操作系统，首先需要实现GDT。
GDT中的Segment descriptor的结构如下：
struct GlobalDescriptor
{
    uint16_t limitLow16;
    uint16_t baseLow16;
    uint8_t baseMid8;
    uint8_t privilege;
    uint8_t flagsAndLimitHigh4;
    uint8_t baseHigh8;
}
limit是20位，也就是1MB。对于kernel这样的程序来说，1MB肯定是不够的。所以考虑分页。当limit超过0xffff时，就采用分页。
page的大小为4KB，也就是0xfff + 1，所以当分页时，limit应该除以4KB，即右移12位。base则直接填到相应位置。

IDT
中断Interrupt是驱动和做process context switch的基础。做这部分首先要建好interrupt descriptor table。
interrupt descriptor的结构如下：
struct interruptDescriptor
{
    uint16_t offsetLowerBits;
    uint16_t segmentSelector;
    uint8_t reserved;
    uint8_t type;
    uint16_t offsetHigherBits;
}
reserved设置为0就行。offset是interrupt vector的offset。interrupt vector是处理程序的地址。
这里可以用汇编编写，然后将标号填到一个数据段中。举个例子：
vector0:
    # handle interrupt 0
vector1:
    # handle interrupt 1
...
vector255:
    # handle interrupt 255

.data 
InterruptVectors:
    .long vector0
    .long vector1
    ...
    .long vector255
在填写interrupt descriptor时，使用extern引用InterruptVectors，即可得到offset：
offset = InterruptVectors[i]
因为处理中断时，处理中断的程序是kernel本身。所以这里的选择子，应该填kernel的代码段的选择子。
段选择子是将段偏移，即在数组中的序号左移3位。





